// Generated by CoffeeScript 1.9.3
var ChainMap, DoubleChain, Iterator, Packet, Series, SortMap, exports, generatorRulers, groupBy, st, through,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

through = require('through');

SortMap = require('sortset').SortMap;

Iterator = require('sortset').Iterator;

st = require("stream-total");

exports = module.exports = groupBy = function(option) {
  var rulers;
  rulers = generatorRulers(option);
  return new Packet(rulers);
};

DoubleChain = (function() {
  function DoubleChain(value1) {
    this.value = value1;
    this.left = null;
    this.right = null;
  }

  DoubleChain.prototype.head = function() {
    if (this.isHead()) {
      return this;
    } else {
      return this.left.head();
    }
  };

  DoubleChain.prototype.tail = function() {
    if (this.isTail()) {
      return this;
    } else {
      return this.right.tail();
    }
  };

  DoubleChain.prototype.orderNumber = function() {
    if (this.isHead()) {
      return 0;
    } else {
      return 1 + this.previous().orderNumber();
    }
  };

  DoubleChain.prototype.count = function() {
    return this.tail().orderNumber() + 1;
  };

  DoubleChain.prototype.indexOf = function(item) {
    var ret;
    ret = -1;
    if (item !== null) {
      this.forEach(function(i) {
        if (i === item) {
          ret = i.orderNumber();
          return true;
        }
      });
    }
    return ret;
  };

  DoubleChain.prototype.previous = function() {
    return this.left;
  };

  DoubleChain.prototype.next = function() {
    return this.right;
  };

  DoubleChain.prototype.isHead = function() {
    return this.left === null;
  };

  DoubleChain.prototype.isTail = function() {
    return this.right === null;
  };

  DoubleChain.prototype.forEach = function(callback) {
    var item, ref;
    if ('function' === typeof callback) {
      item = this.head();
      while (item !== null && ((ref = callback(item)) === (void 0) || ref === null || ref === false)) {
        item = item.next();
      }
    }
  };

  DoubleChain.prototype.get = function(pos) {
    var ret;
    ret = null;
    this.forEach(function(item) {
      if (item.orderNumber() === pos) {
        ret = item;
        return true;
      }
    });
    return ret;
  };

  DoubleChain.prototype.join = function(chain) {
    var rightHead, rightTail;
    if (this.indexOf(chain) < 0) {
      rightHead = chain.head();
      rightTail = chain.tail();
      rightHead.left = this;
      rightTail.right = this.right;
      if (!this.isTail()) {
        this.right.left = rightTail;
      }
      this.right = rightHead;
      return true;
    } else {
      return false;
    }
  };

  DoubleChain.prototype.divide = function(len) {
    var d_count, head, i, item, j, num, ret;
    ret = [];
    d_count = this.count();
    head = this.head();
    if (d_count >= len && len > 0) {
      j = 0;
      num = Math.floor(d_count / len);
      while (j < num) {
        if (head !== null) {
          ret.push(head);
        }
        item = head;
        i = 0;
        while (i < len && item !== null) {
          i++;
          item = item.next();
        }
        head = item;
        if (head !== null) {
          head.cut();
        }
        j++;
      }
    }
    if (d_count % len > 0) {
      ret.push(head);
    }
    return ret;
  };

  DoubleChain.prototype.cut = function() {
    var item, ret;
    item = this;
    if (item.isHead()) {
      return [item];
    }
    ret = [item.head()];
    item.left.right = null;
    item.left = null;
    ret.push(item);
    return ret;
  };

  DoubleChain.prototype.remove = function() {
    var item;
    item = this;
    if (this.count() > 1) {
      if (item.isHead()) {
        item.right.left = null;
      } else {
        if (!item.isTail()) {
          item.right.left = item.left;
        }
      }
      if (item.isTail()) {
        item.left.right = null;
      } else {
        if (!item.isHead()) {
          item.left.right = item.right;
        }
      }
    }
    item.left = item.right = null;
    return item;
  };

  DoubleChain.prototype.addHead = function(value) {
    var ret;
    ret = new DoubleChain(value);
    ret.right = this.head();
    ret.left = null;
    this.head().left = ret;
    return ret;
  };

  DoubleChain.prototype.addTail = function(value) {
    var ret;
    ret = new DoubleChain(value);
    ret.left = this.tail();
    ret.right = null;
    this.tail().right = ret;
    return ret;
  };

  DoubleChain.prototype.toArray = function() {
    var ret;
    ret = [];
    this.forEach(function(item) {
      ret.push(item.value);
      return false;
    });
    return ret;
  };

  DoubleChain.prototype.clone = function() {
    var head, item, k, len1, ret;
    ret = this.toArray();
    head = new DoubleChain(ret.shift());
    for (k = 0, len1 = ret.length; k < len1; k++) {
      item = ret[k];
      head.addTail().value = item;
    }
    return ret = head;
  };

  DoubleChain.prototype.find = function(value, eq) {
    var ret;
    eq = eq || function(a, b) {
      return a === b;
    };
    ret = [];
    this.forEach(function(item) {
      if (eq(item.value, value)) {
        return ret.push(item);
      }
    });
    return ret;
  };

  DoubleChain.prototype.findFirst = function(value, eq) {
    var ret;
    eq = eq || function(a, b) {
      return a === b;
    };
    ret = null;
    this.forEach(function(item) {
      if (eq(item.value, value)) {
        ret = item;
        return true;
      }
    });
    return ret;
  };

  return DoubleChain;

})();

DoubleChain.readArray = function(array) {
  var head, item, k, len1, ret;
  head = new DoubleChain;
  if (array instanceof Array && array.length) {
    for (k = 0, len1 = array.length; k < len1; k++) {
      item = array[k];
      head.addTail().value = item;
    }
  }
  ret = head.next();
  head.remove();
  return ret;
};

ChainMap = (function(superClass) {
  extend(ChainMap, superClass);

  function ChainMap() {
    return ChainMap.__super__.constructor.apply(this, arguments);
  }

  ChainMap.prototype.compare = function(a, b) {
    var ret;
    a = a.key.head();
    b = b.key.head();
    ret = 1;
    a.forEach(function(a_item) {
      var b_item;
      b_item = b.get(a_item.orderNumber());
      ret = a_item.value > b_item.value ? 1 : a_item.value < b_item.value ? -1 : 0;
      return ret !== 0;
    });
    return ret;
  };

  return ChainMap;

})(SortMap);

Packet = (function() {
  function Packet(rulers1) {
    this.rulers = rulers1;
    this.series = new Series;
  }

  Packet.prototype.stream = function(template) {};

  Packet.prototype.readArray = function(array) {
    return this.readIterator(new Iterator(array));
  };

  Packet.prototype.readIterator = function(iterator) {
    var head, root;
    root = new DoubleChain("root");
    Iterator.forEach(iterator, function(doc) {
      var d_series;
      d_series = this.rulers.exec(doc);
      root.tail().join(DoubleChain.readArray(d_series));
      root.tail().doc = doc;
      return false;
    });
    head = root.next();
    return root.remove();
  };

  return Packet;

})();

Series = (function() {
  function Series() {
    this.data = new ChainMap;
  }

  Series.prototype.total = function(template) {};

  Series.prototype.forEach = function(callback) {};

  return Series;

})();

generatorRulers = function(option) {
  var field, index, k, len1, ruler, rulers;
  rulers = {
    items: new SortMap,
    exec: function(doc) {
      var ret;
      ret = [];
      this.items.forEach(function(key, ruler) {
        return ret.push({
          name: key,
          value: ruler.exec(doc)
        });
      });
      return ret;
    },
    add: function(ruler) {
      return this.items.add(ruler.name, ruler);
    },
    count: function() {
      return this.items.size;
    }
  };
  if (!option instanceof Array) {
    option = option.split(',');
  }
  for (index = k = 0, len1 = option.length; k < len1; index = ++k) {
    field = option[index];
    ruler = {
      name: field,
      exec: function(doc) {
        return doc[this.name];
      }
    };
    if ('function' === typeof field) {
      ruler = {
        name: "Series " + index,
        exec: field
      };
    }
    rulers.add(ruler);
  }
  return rulers;
};

exports.Chain = DoubleChain;

exports.ChainMap = ChainMap;

//# sourceMappingURL=groupby.js.map
